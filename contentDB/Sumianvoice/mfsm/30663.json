{
  "author": "Sumianvoice",
  "content_warnings": [],
  "created_at": "2024-11-23T10:46:03.088121",
  "dev_state": "MAINTENANCE_ONLY",
  "donate_url": null,
  "downloads": 75,
  "forum_url": null,
  "forums": null,
  "game_support": [],
  "issue_tracker": null,
  "license": "0BSD",
  "long_description": "\n## Multiple Finite State Machine\nThis allows you to have multiple states active at one time, while also allowing for typical finite state machine behaviors, like going from one state to the next and the next etc.\n\nHere's how you use it. There are two ways; you could put it on an entity, or you could insert it into a plain table. Either way you'll want something like this.\n\n## For entities\n```lua\nminetest.register_entity(\"my_mod:mob\", {\n    on_step = function(self, dtime, moveresult)\n        MFSM.on_step(self, dtime) -- this and _MFSM_states is all you need\n        if not self._init then\n            self._init = true\n            -- can't self:set_state because we can't `setmetatable` on entities, so we just do it oldschool\n            MFSM.set_state(self, \"idle\", true, false)\n        end\n    end,\n    _MFSM_states = {\n        {\n            name = \"idle\",\n            on_step = function(self, dtime, meta)\n            end,\n            on_start = function(self, meta)\n            end,\n            on_end = function(self, meta)\n            end,\n            protected = true,\n        },\n        {\n            name = \"follow\",\n            [...]\n        },\n    },\n})\n```\n\n## For any `table`\n```lua\nlocal my_statemachine = MFSM.new({\n    _MFSM_states = {\n        {\n            name = \"idle\",\n            on_step = function(self, dtime, meta)\n            end,\n            on_start = function(self, meta)\n            end,\n            on_end = function(self, meta)\n            end,\n            protected = true,\n        },\n        {\n            name = \"follow\",\n            [...]\n        },\n    },\n})\n-- if you want it to run all the time\nMFSM.enable_globalstep(my_statemachine)\nMFSM.set_state(my_statemachine, \"idle\", true, false)\n```\n\n## Things you need\n`_MFSM_states` --> `table` list of all states, with their names and methods.\n\n`[state].protected` --> `boolean` for whether to protect this so it doesn't get stopped by `exclusive` set_state calls.\n\nThe rest is up to you.\n\n## Functions\nAll of these can also be `self:method()` or `my_statemachine:method()` instead of `MFSM.method(my_statemachine)`, so you can call them from within the statemachine itself.\n\nTo set states:\n```lua\nMFSM.set_state(self, state_name, active, exclusive)\nMFSM.set_state(self, states, exclusive)\n```\nExample:\n```lua\n-- set to idle, but don't stop other states\nMFSM.set_state(my_statemachine, \"idle\", true, false)\n-- set to idle, and disable roam state, don't stop any other states\nMFSM.set_states(my_statemachine, {\n    idle = true,\n    roam = false,\n}, false)\n```\n\n\nStart tracking it so that `on_step` happens automatically.\n```lua\nMFSM.enable_globalstep(my_statemachine)\n```\nStop tracking it.\n```lua\nMFSM.disable_globalstep(my_statemachine)\n```\n\nAll methods. These are all `self:method()`-able.\n```lua\nMFSM.init_states(self)\nMFSM.get_state_meta(self, state_name)\nMFSM.do_state(self, state_name, functype, ...)\nMFSM.set_state(self, state_name, active, exclusive)\nMFSM.set_states(self, states, exclusive)\nMFSM.on_step(self, dtime)\nMFSM.reset_all_states(self, exclude_list)\nMFSM.enable_globalstep(self)\nMFSM.disable_globalstep(self)\n```\n\nIn addition, the API will try to call these functions on your table or entity when changing states, so you can use them for callbacks.\n```lua\n_MFSM_on_any_state_start(self, state_name, meta)\n_MFSM_on_any_state_end(self, state_name, meta)\n```\n\n\nWith comments explaining stuff:\n```lua\n-- the host table you're going to put the states in\nlocal my_table = {\n    -- this is the name it expects; it must have this field or nothing will happen\n    _MFSM_states = {}\n}\n-- table insert is clean but you can just dump them in the {} and be done with it too (like above)\n-- on_step for each state is called IN ORDER that it exists within this list, so the order matters here\ntable.insert(my_table._MFSM_states, {\n    name = \"start\", -- must be unique\n    -- meta is a table you can store arbitrary data in, and it is unique to this state\n    -- when the state ends, the meta gets destroyed\n    on_step = function(self, dtime, meta)\n        if meta.state_time > 10 then\n            -- state_name, value, exclusive : whether to end other states that aren't `protected`\n            self:set_state(\"end\", true, false)\n        end\n    end,\n    -- called once whn the state starts\n    on_start = function(self, meta)\n        core.log(\"started\")\n    end,\n    -- called once when the state stops\n    on_end = function(self, meta)\n    end,\n    -- will not be ended when set_state is used with exclusive = true\n    protected = true,\n})\n-- another state, this one runs after the first one\ntable.insert(my_table._MFSM_states, {\n    name = \"end\",\n    on_step = function(self, dtime, meta)\n    end,\n    on_start = function(self, meta)\n        core.log(\"got to end\")\n    end,\n    on_end = function(self, meta)\n    end,\n    protected = false,\n})\n\n-- initialises it so it is using all the mfsm methods\nmy_table = MFSM.new(my_table)\n-- the system will automatically call on_step for this now\n-- don't use for entities obviously, since it would call twice per step\nmy_table:enable_globalstep()\n```",
  "maintainers": ["Sumianvoice"],
  "media_license": "0BSD",
  "name": "mfsm",
  "provides": ["mfsm"],
  "release": 30663,
  "repo": "https://codeberg.org/SumianVoice/MFSM_statemachine.git",
  "score": 1,
  "screenshots": ["https://content.luanti.org/uploads/5825dc4c96.jpg"],
  "short_description": "Allows for multple states to be active, while maintaining typical state machine behavior. Good for gamestate and mobs.",
  "state": "APPROVED",
  "tags": [],
  "thumbnail": "https://content.luanti.org/thumbnails/1/5825dc4c96.png",
  "title": "MFSM Multiple Finite State Machine",
  "translation_url": null,
  "type": "mod",
  "url": "https://content.luanti.org/packages/Sumianvoice/mfsm/releases/30663/download/",
  "video_thumbnail_url": null,
  "video_url": null,
  "website": null,
  "dependencies": { "Sumianvoice/mfsm": [] },
  "hash": "1sqipzpgaby2i5qcavw0qsh7478wbg31jzipyx7hdva2izjjqi75"
}
