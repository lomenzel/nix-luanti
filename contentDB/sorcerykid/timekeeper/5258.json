{
  "author": "sorcerykid",
  "content_warnings": [],
  "created_at": "2020-09-30T21:50:30.386828",
  "dev_state": null,
  "donate_url": "https://liberapay.com/sorcerykid",
  "downloads": 1083,
  "forum_url": "https://forum.luanti.org/viewtopic.php?t=25142",
  "forums": 25142,
  "game_support": [],
  "issue_tracker": null,
  "license": "MIT",
  "long_description": "The Timekeeper class provides a simple and efficient means of executing code at regular intervals. The constructor itself is global, so typically it will be used in conjunction with entities.\n\n* **Timekeeper( this )**  \nInstantiates and returns a new timekeeper object, with an optional meta table for use by callbacks (typically this will be a reference to the entity itself). Ideally the Timekeeper constructor will be called as soon as the LuaEntitySAO has been added to the environment.\n\n```\non_activate(self)\n        self.timekeeper = Timekeeper(self)\n        :\nend\n```\n\nThe following methods are available:\n\n* **timekeeper.start( period, name, func, delay )**  \nBegins a new timer with the given name and period. The callback will execute no sooner than the next server step. If the callback returns false, then the timer will be cancelled and removed from the queue. An optional delay can be specified to avoid concurrency with other running timers.\n\n* **timekeeper.start_now( period, name, func )**  \nIdentical to timekeeper.start(), except the first iteration of the callback will be executed immediately.\n\n* **timekeeper.clear( name )**  \nCancels an existing timer with the given name.\n\nFour parameters are provided to the timer callback for each iteration:\n\n* this - the meta table that was originally passed to the constructor\n* cycles - the number of cycles that have accrued, beginning at 1\n* period - the interval between each cycle\n* elapsed - the elapsed time for all cycles\n* overrun - the overrun time from the last cycle\n\nIn order for the timers to be processed correctly, you must call the on_step() method of the timekeeper object during every server step. For example, in the case of entities:\n\n```lua\non_step = function (dtime)\n        local timers = self.timekeeper.on_step(dtime)\n\nend,\n```\n\nWith a globalstep callback, it is similar albeit the timekeeper object will likely be defined at the head of the script.\n\n```lua\nlocal timekeeper = Timekeeper { }\n\nminetest.register_globalstep(function(dtime)\n        local timers = timekeeper.on_step(dtime)\nend)\n```\n\nNotice that the on_step method of the timekeeper object returns a table of timers. This can be useful for processing one or more timer events directly within the globalstep callback.\n\nFor convenience, a global timekeeper object is  available for use by all mods. This can avoid the need to register additional globalsteps when a simple timer mechanism is all that is required. In this case, it is  recommened that timer names be prefixed with the mod name and a colon to avoid collisions.\n\nHere is an example mod that displays the player's orientation at the bottom of the screen.\n\n```lua\nlocal player_huds = { }\n\nlocal dir_names = {\n\t[\"N\"] = \"north\",\n\t[\"NE\"] = \"northeast\",\n\t[\"E\"] = \"east\",\n\t[\"SE\"] = \"southeast\",\n\t[\"S\"] = \"south\",\n\t[\"SW\"] = \"southwest\",\n\t[\"W\"] = \"west\",\n\t[\"NW\"] = \"northwest\",\n\t[\"U\"] = \"up\",\n\t[\"D\"] = \"down\",\n}\n\nminetest.register_on_joinplayer( function( player )\n        local player_name = player:get_player_name( )\n\n        player_huds[ player_name ] = player:hud_add( {\n                hud_elem_type = \"text\",\n                text = \"\",\n                position = { x = 0.5, y = 1 },\n                scale = { x = -100, y = -100 },\n                number = 0xFFFFFF,\n                alignment = { x = 0, y = 0 },\n                offset = { x = 0, y = -105 }\n        } )\nend )\n\nminetest.register_on_leaveplayer( function( player )\n\tplayer_huds[ player:get_player_name( ) ] = nil\nend )\n\nlocal function to_facing( dir )\n\tlocal dx = math.floor( dir.x + 0.5 )\n\tlocal dz = math.floor( dir.z + 0.5 )\n\n\tif dx == 0 and dz == 0 then\n\t\treturn dir.y > 0 and \"U\" or \"D\"\n\telse\n\t\treturn ( { [1] = \"N\", [0] = \"\", [-1] = \"S\" } )[ dz ] .. ( { [1] = \"E\", [0] = \"\", [-1] = \"W\" } )[ dx ]\n\tend\nend\n\nglobaltimer.start( 2.5, \"sample_mod:update_hud\", function ( this, cycles )\n\tfor _, player in ipairs( minetest.get_connected_players( ) ) do\n\t\tlocal cur_dir = to_facing( player:get_look_dir( ) )\n\t\tlocal player_name = player:get_player_name( )\n\t\tplayer:hud_change( player_huds[ player_name ], \"text\", string.format( \"You are facing %s\", dir_names[ cur_dir ] ) )\n\tend\nend )\n```",
  "maintainers": [
    "sorcerykid"
  ],
  "media_license": "MIT",
  "name": "timekeeper",
  "provides": [
    "timekeeper"
  ],
  "release": 5258,
  "repo": "https://bitbucket.org/sorcerykid/timekeeper.git",
  "score": 2.5,
  "screenshots": [
    "https://content.luanti.org/uploads/EZXRxCJUTN.png"
  ],
  "short_description": "Timekeeper acts as a centralized dispatcher for all time-sensitive routines",
  "state": "APPROVED",
  "tags": [
    "library"
  ],
  "thumbnail": "https://content.luanti.org/thumbnails/1/EZXRxCJUTN.png",
  "title": "Timekeeper",
  "translation_url": null,
  "type": "mod",
  "url": "https://content.luanti.org/packages/sorcerykid/timekeeper/releases/5258/download/",
  "video_thumbnail_url": null,
  "video_url": null,
  "website": null,
  "dependencies": {
    "sorcerykid/timekeeper": []
  },
  "hash": "15jrr58mcz5fk5gyrcvnmk9sckjc2zhplrcs39js8d8b1nz736kv"
}
