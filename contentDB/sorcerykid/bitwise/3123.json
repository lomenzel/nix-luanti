{"author":"sorcerykid","content_warnings":[],"created_at":"2020-03-04T15:34:01.374180","dev_state":null,"donate_url":"https://liberapay.com/sorcerykid","downloads":1204,"forum_url":"https://forum.luanti.org/viewtopic.php?t=24288","forums":24288,"game_support":[],"issue_tracker":null,"license":"MIT","long_description":"Bitwise Operations is a pure-Lua implementation of various bit-manipulation functions, including conversion to and from strings and numbers via binary notation as well as an additional binary option to string.format().\n\nBitwise Operations may be installed either as a Minetest mod or as a standalone library for use in command-line scripts. The usage instructions below apply the same in either scenario.\n\nFor numeric bit operations, the following functions are available globally:\n\n* AND(), OR(), XOR(), NOT(), LSHIFT() and RSHIFT()\n\nAll other library functions can be accessed via the 'bitwise' namespace. For improvedperformance, you may want to localize the functions to bits_<func>.\n\n```\nlocal bits_format = bitwise.format\nlocal bits_unpack = bitwise.unpack\nlocal bits_pack = bitwise.pack\nlocal bits_to_string = bitwise.to_string\nlocal bits_from_string = bitwise.from_string\nlocal bits_pack_string = bitwise.pack_string\nlocal bits_not = bitwise.NOT\nlocal bits_and = bitwise.AND\nlocal bits_or = bitwise.OR\nlocal bits_xor = bitwise.XOR\nlocal bits_lshift = bitwise.LSHIFT\nlocal bits_rshift = bitwise.RSHIFT\nlocal bits_new = bitwise.new\n```\n\t\nAll of these functions can prove useful when debugging, or any application where you need to examine and manipulate individual bits of either numbers or strings.\n\t\n**\tbitwise.format( str, ... )**  \nExtends the string.format( ) function with an additional %b format specifier for outputting numbers in binary notation. The str is a string that consists of one or more format specifiers, each associated with an argument for substitution.\n\t\n%[flag][field-width][:group-width]b\n\t\nThe %b format specifier accepts a flag of either 0 to pad the field with leading zeroes or to left-justify the field. With no flag, the field will be padded with leading spaces instead. If no field width is specified then the only the minimumdigits necessary to represent the number in binary notation will be shown, with no leading spaces or zeros. If the field is not wide enough to accommodate the entire number in binary notation, then it will be extended (no digits will be truncated). Sets of bits may also be evenly spaced provided an optional group width.\n\n```\nprint( bitwise.format( \"%032:4b\", 65000 ) )\n--> 0000 0000 0000 0000 1111 1101 1110 1000\n```\n\t\n**bitwise.new( size, value )**  \nCreates a new bit field (boolean array) for easily working with individual bits on the fly using Lua's builtin boolean operators.\n\t\n* size is the length of the bit field (required)\n* value is the boolean value to assign to each bit (defaults to false)\n\n```\n**bitwise.new( 4, true )**\n==> { true, true, true, true }\n```\n\t\n**bitwise.unpack( val, size )**  \nUnpacks a number into a bit field.\n\t\n* num is the unsigned integer to unpack (required)\n* size is the length of the bit field to create, limited to 56-bits (required)\n\n```\nbitwise.unpack( 16, 150 )\n==> { true, false, false, true, false, true, true, false }\n```\n\t\n**bitwise.pack( bits )**  \nPacks a bit field into a number.\n\t\n* bits is the bit field to unpack, limited to 56 elements (required)\n\n```\nprint( bitwise.pack( { true, false, false, false, false, false, false, false } )\n--> 128\n```\n\n**bitwise.pack_string( bits )**  \nPacks a bit field of arbitrary length into a string. Each set of 8 elements will produce an additional ASCII character.\n\n* bits is the bit field to unpack (required)\n\t\n```\nprint( bitwise.pack_string( { false, true, true, true, false, true, true, true } ) )\n--> w\n```\n\n**bitwise.to_string( bits, div )**  \nTransforms a bit field of arbitrary length into a binary-notation string.\n\n* bits is the bit field to transform into a string (required)\n* div is the group width for evenly spacing bits (optional)\n\n```\nprint( bitwise.to_string( { true, false, true, true, false, true, true, true }, 4 ) )\n--> 1011 0111\n```\n\n**bitwise.from_string( str )**  \nParses a binary-notation string and transforms it into a bit field.\n\n* str is the string to transform into a bit field (required)\n\n```\nbitwise.from_string( \"1001\" )\n==> { true, false, false, true }\n```\n\n**bitwise.binary( str )**  \nParses a binary-notation string and converts it into a number.\n\n* str is the string to convert into a number (required)\n\t\n```\nbitwise.binary( \"00010010101110010001\" )\n==> 76689\n```\n\n**AND( num1, num2 )**  \nPerforms a logical bitwise AND operation on two numbers.\n\n* num1 is an unsigned integer\n* num2 is an unsigned integer\n\t\nOR( num1, num2 )\nPerforms a logical bitwise OR operation on two numbers. The number with the most significant bit set will determine the resulting bit pattern's length.\n\t\n* num1 is an unsigned integer\n* num2 is an unsigned integer\n\t\n**XOR( num1, num2 )**\nPerforms a logical bitwise XOR operation on two numbers. The number with the most significant bit set will determine the resulting bit pattern's length.\n\t\n* num1 is an unsigned integer\n* num2 is an unsigned integer\n\t\n**NOT( num )**  \nPerforms a logical bitwise NOT operation on a number.\n\t\n* num is an unsigned integer\n\t\nFor finer grained control of the resulting bit-pattern length, you can provide a mask with the XOR() functions rather than using the NOT() function:\n\n```\nNOT( 0x0F )\n==> 0x00\nXOR( 0x0F, 0xFF )\n==> 0xF0\n```\n\n**NOT16( num )**  \nPerforms a logical bitwise NOT operation on a 16-bit number.\n\t\n* num is an unsigned integer\n\t\nThe result is undefined for numbers larger than 16-bits, so be sure to mask the input using the AND() function if in doubt.\n\n**NOT32( num )**  \nPerforms a logical bitwise NOT operation on a 32-bit number.\n\t\n* num is an unsigned integer\n\t\nThe result is undefined for numbers larger than 32-bits, so be sure to mask the input using the AND() function if in doubt.","maintainers":["sorcerykid"],"media_license":"MIT","name":"bitwise","provides":["bitwise"],"release":3123,"repo":"https://bitbucket.org/sorcerykid/bitwise","score":2.8,"screenshots":["https://content.luanti.org/uploads/OpXjovUhHQ.png"],"short_description":"A pure-Lua implementation of common bit-manipulation functions","state":"APPROVED","tags":["library"],"thumbnail":"https://content.luanti.org/thumbnails/1/OpXjovUhHQ.png","title":"Bitwise Operations","translation_url":null,"type":"mod","url":"https://content.luanti.org/packages/sorcerykid/bitwise/releases/3123/download/","video_thumbnail_url":null,"video_url":null,"website":null,"dependencies":{"sorcerykid/bitwise":[]},"hash":"08bvxp7x07qm72m64lmpa03ws2sbr5yb2javhqh7br6j2i4ikp0l"}