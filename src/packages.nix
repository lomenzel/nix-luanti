{
  pkgs,
  ...
}:
with builtins;
let
  inherit (pkgs)
    lib
    fetchurl
    unzip
    p7zip
    writeText
    ;
  inherit (pkgs.stdenv) mkDerivation;

  flattenPackageSet =
    nested:
    let
      allPackages = lib.lists.concatLists (map (lib.attrsToList) (attrValues nested));
      disambiguatedpackages = map (
        { name, value }@package:
        if length (filter (p: p.name == name) allPackages) > 1 then
          package // { name = "${name}_by_${value.author}"; }
        else
          package
      ) allPackages;

    in
    listToAttrs disambiguatedpackages;

  buildLuantiModPack =
    {
      name ? "extra-mods",
      mods ? [ ],
      description ? "Modpack generated by Nix configuration",
    }:
    mkDerivation {
      pname = "${name}";
      version = "";
      src = null;
      dontUnpack = true;
      installPhase = ''
        mkdir -p $out
        ln -s ${writeText "modpack.conf" ''
          name = ${name}
          description = ${description}
        ''} $out/modpack.conf
        ${concatStringsSep "\n" (
          map (mod: ''
            ln -s ${mod} $out/${mod.name}
          '') mods
        )}
      '';
    };

  fetchFromLuantiContentDB =
    {
      name,
      author,
      description ? "No description Provided",
      type ? null,

      release,
      hash,
    }:
    mkDerivation {
      version = toString release;
      pname = "source-${name}-${author}";
      src = fetchurl {
        name = "source-archive-of-${name}";
        url = "https://content.luanti.org/packages/${lib.escapeURL author}/${lib.escapeURL name}/releases/${builtins.toString release}/download?reason=nix-luanti-installation";
        sha256 = hash;
      };
      unpackPhase = ''
        mkdir extracted
        ${p7zip}/bin/7z x $src -oextracted -aoa
      '';

      installPhase = ''
        echo 'installphase started'
        mkdir -p $out
        mkdir package


        if [ -d extracted ] && \
           [ "$(find extracted -mindepth 1 -maxdepth 1 -type d | wc -l)" -eq 1 ] && \
           [ "$(find extracted -mindepth 1 -maxdepth 1 ! -type d | wc -l)" -eq 0 ]; then

           for dir in extracted/*/; do
            cp -r "$dir"* package/
          done
        else
          cp -r extracted/* package/

        fi

        if find package -maxdepth 1 -name '*.conf' | grep -q .; then
          echo '.conf found'
        else
          ${
            if type != "texturePack" && type != "mod" then
              ''
                echo 'the package that is missing a .conf file may not be a texture Pack. add type = texturePack to fetchFromContentDB arguments if you are sure that this is indeed a texturepack'
                exit 1
              ''
            else
              ''
                echo 'Warning: this package is missing a .conf file. generating a minimal one'
              ''
          }
          cat <<EOT > package/${
            if type == "texturePack" then
              "texture_pack"
            else if type == "mod" then
              "mod"
            else
              "unknown"
          }.conf
        name = ${name}
        description = ${description}
        EOT
        fi

        cp -r package/* $out/
      '';
    };

  buildLuantiGame = lib.extendMkDerivation {
    constructDrv = mkDerivation;
    extendDrvArgs =
      finalAttrs:
      {
        pname,
        version,
        src,
        author ? "unknown",
        repo ? null,
        provides ? [ ],
        mods ? [ ],
        description ? "",
        buildPhase ? "true",
        passthru ? { },
        meta ? { },
        installPhase ? ''
          mkdir -p $out
          cp -r $src/* $out/
        '',
        ...
      }@attr:
      let

        supported_mods = lib.filterAttrs (
          mod_name: mod:
          hasAttr "supported_games" mod
          && elem {
            inherit author;
            name = pname;
          } mod.supported_games
        ) modsDB;
        all_mods = modsDB;

        notFound =
          name:
          throw "Could not resolve all dependencies for ${pname} (${version}) with mods. needing mod ${name}";
        all_provides =
          modList: lib.lists.unique (attr.provides ++ concatLists (map (m: m.provides or [ ]) modList));
        all_dependencies = modList: lib.lists.unique (concatLists (map (m: m.dependencies or [ ]) modList));
        missing_deps = modList: lib.subtractLists (all_provides modList) (all_dependencies modList);
        mods_needed' =
          modList:
          let
            _missing_deps = missing_deps modList;
          in
          if _missing_deps == [ ] then
            modList
          else
            let
              missing_mod = head (_missing_deps);
              provide = attrSet: lib.filterAttrs (n: v: elem missing_mod v.provides) attrSet;
              prov_supported_mods = provide supported_mods;
              prov_other_mods = provide all_mods;
            in
            if hasAttr missing_mod supported_mods then
              mods_needed' (modList ++ lib.singleton prov_supported_mods.${missing_mod})
            else if hasAttr missing_mod all_mods then
              mods_needed' (modList ++ lib.singleton prov_other_mods.${missing_mod})
            else
              let
                prov_mods = attrValues prov_supported_mods ++ attrValues prov_other_mods;
              in
              if length prov_mods > 0 then
                mods_needed' (modList ++ lib.singleton (head prov_mods))
              else
                notFound missing_mod;

        mods_needed = mods_needed' mods;
      in
      {
        inherit
          src
          pname
          installPhase
          buildPhase
          ;
        fixupPhase = ''
          ls -lah $out
          mkdir -p $out/mods/
          chmod +w $out/mods
          ln -s ${buildLuantiModPack { mods = mods_needed; }} $out/mods/nix-luanti-generated-modpack
        '';
        version = toString version;
        passthru = rec {
          withMods =
            f:
            buildLuantiGame (
              attr
              // {
                mods = lib.lists.unique (mods ++ f supported_mods);
              }
            );
          inherit author;
        }
        // passthru;
        meta = {
          inherit description;
          homepage = if repo == null then "https://content.luanti.org/packages/${author}/${pname}" else repo;
        }
        // meta;
      };
  };

  buildLuantiMod = lib.extendMkDerivation {
    constructDrv = mkDerivation;
    extendDrvArgs =
      finalAttrs:
      {
        name,
        version ? "0.0.0",
        author ? "unknown",
        src,
        description ? "",
        provides ? [ ],
        buildPhase ? "true",
        dependencies ? [ ],
        passthru ? { },
        meta ? { },
        installPhase ? ''
          mkdir -p $out
          cp -r $src/* $out/
        '',
        ...
      }@attr:
      {
        pname = "luanti-mod-${name}";
        inherit
          version
          src
          installPhase
          buildPhase
          ;
        passthru = {
          dependencies = attr.dependencies;
          provides = attr.provides;
          inherit author;
        }
        // passthru;
        meta = {
          inherit description;
          homepage =
            if hasAttr "repo" attr then attr.repo else "https://content.luanti.org/packages/${author}/${name}";
        }
        // meta;
      };
  };

  modsDB = flattenPackageSet (
    mapAttrs (
      author: modsFromAuthor:
      mapAttrs (
        name: details:
        buildLuantiMod {
          inherit name;
          version = details.release;
          src = fetchFromLuantiContentDB {
            inherit name author;
            type = "mod";
            inherit (details) release hash;
            description =
              if hasAttr "short_description" details then
                details.short_description
              else
                "No description for this mod provided";

          };
          inherit author;
          repo = if hasAttr "repo" details then details.repo else null;
          provides = if hasAttr "provides" details then details.provides else [ ];
          dependencies = if hasAttr "dependencies" details then details.dependencies else [ ];
          description = if hasAttr "short_description" details then details.short_description else "";
          passthru.supported_games = if hasAttr "game_support" details then details.game_support else [ ];
        }
      ) modsFromAuthor
    ) contentDB.mods
  );

  contentDB = lib.importJSON ../generated/contentDB.json;

  buildLuantiTexturePack = lib.extendMkDerivation {
    constructDrv = mkDerivation;
    extendDrvArgs =
      finalAttrs:
      {
        name,
        author,
        version ? "0.0.0",
        src,
        description ? "",
        passthru ? { },
        buildPhase ? "",
        meta ? { },
        installPhase ? ''
          mkdir -p $out
          cp -r $src/* $out/
        '',
        ...
      }@attr:
      {
        pname = "luanti-texture-pack-${name}";
        inherit
          version
          src
          installPhase
          buildPhase
          ;
        passthru = passthru;
        meta = {
          inherit description;
          homepage = if hasAttr "repo" attr then attr.repo else null;
        }
        // meta;
      };
  };
in
{

  luantiPackages = {
    games = flattenPackageSet (
      mapAttrs (
        author: gamesFromAuthor:
        mapAttrs (
          name: details:
          buildLuantiGame {
            pname = name;
            version = details.release;
            src = fetchFromLuantiContentDB {
              inherit name author;
              inherit (details) release hash;
            };
            inherit author;
            repo = if hasAttr "repo" details then details.repo else null;
            provides = if hasAttr "provides" details then details.provides else [ ];
            description = if hasAttr "short_description" details then details.short_description else "";

          }
        ) gamesFromAuthor
      ) contentDB.games
    );
    mods = modsDB;
    texturePacks = flattenPackageSet (
      mapAttrs (
        author: texturePacksFromAuthor:
        mapAttrs (
          name: details:
          if hasAttr "release" details then
            buildLuantiTexturePack {
              inherit name author;
              version = details.release;
              src = fetchFromLuantiContentDB {
                inherit name author;
                inherit (details) release hash;
                type = "texturePack";
                description =
                  if hasAttr "short_description" details then
                    details.short_description
                  else
                    "No description for this texturePack was provided";
              };
              description = if hasAttr "short_description" details then details.short_description else "";
              passthru = if hasAttr "passthru" details then details.passthru else { };
              meta = if hasAttr "meta" details then details.meta else { };
            }
          else
            throw "Texture pack ${name} by ${author} does not have a release defined"
        ) texturePacksFromAuthor
      ) contentDB.texturePacks
    );
    clientMods = import ./clientMods pkgs;
  };
  inherit
    buildLuantiMod
    buildLuantiModPack
    buildLuantiGame
    buildLuantiTexturePack
    fetchFromLuantiContentDB
    ;
  luanti-wasm = pkgs.callPackage ./luanti-wasm.nix { };
}
